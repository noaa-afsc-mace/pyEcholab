# coding=utf-8

#    National Oceanic and Atmospheric Administration
#    Alaskan Fisheries Science Center
#    Resource Assessment and Conservation Engineering
#    Midwater Assessment and Conservation Engineering

# THIS SOFTWARE AND ITS DOCUMENTATION ARE CONSIDERED TO BE IN THE PUBLIC DOMAIN
# AND THUS ARE AVAILABLE FOR UNRESTRICTED PUBLIC USE. THEY ARE FURNISHED "AS
# IS." THE AUTHORS, THE UNITED STATES GOVERNMENT, ITS INSTRUMENTALITIES,
# OFFICERS, EMPLOYEES, AND AGENTS MAKE NO WARRANTY, EXPRESS OR IMPLIED, AS TO
# THE USEFULNESS OF THE SOFTWARE AND DOCUMENTATION FOR ANY PURPOSE.  THEY
# ASSUME NO RESPONSIBILITY (1) FOR THE USE OF THE SOFTWARE AND DOCUMENTATION;
# OR (2) TO PROVIDE TECHNICAL SUPPORT TO USERS.

'''
.. module:: echolab2.instruments.echosounder

    :synopsis:  The top level interface for reading data files collected
                using scientific echosounders commonly used in fisheries
                stock assessment and research.

    The echosounder module provides a simplified interface for reading raw data
    generated by EK60, EK80, and similar instruments. Due to the wide variety of
    instruments that utilize the Simrad "raw" data format and their many configuration
    options, pyEcholab's classes for working with these data are complex. The
    echosounder module makes a few assumptions that are applicable to most use
    cases that significantly reduces this complexity. These assumptions are:

        All raw files passed to the read() function will have the same general
        file format (EK60 or EK80). If you pass a list of multiple files to
        read() where some are EK60 formatted and some are EK80, an error will
        be raised.

        All files passed to the read() function will contain the same data type.
        The data types are power only, angles only, power+angles, and complex.
        Mixing types will not result in an error, but only one type of data
        will be returned.

    If you need to read different formats, or different data types you can read
    them separately and combine after they have been read and converted, or you
    can implement something more complex using the EK60 and/or EK80 objects
    directly.




| Developed by:  Rick Towler   <rick.towler@noaa.gov>
| National Oceanic and Atmospheric Administration (NOAA)
| Alaska Fisheries Science Center (AFSC)
| Midwater Assesment and Conservation Engineering Group (MACE)
|
| Authors:
|       Rick Towler   <rick.towler@noaa.gov>
| Maintained by:
|       Rick Towler   <rick.towler@noaa.gov>

$Id$
'''

import os
from . import EK80
from . import EK60
from .util import simrad_utils
import numpy as np


SIMRAD_EK60 = 0
SIMRAD_EK80 = 1

def read(files, ignore_errors=False, **kwargs):
    """read reads one or more Simrad EK60 style *OR* EK80 style .raw data files
    and returns a EK60 or EK80 object containing the data. Supported systems are:

        Simrad EK60, ES60, ME70, ES70, EK80, ES80

    The simplified interface provided by the echosounder module assumes that
    all files will have the same format (EK60 or EK80) and that they will all
    contain the same basic data type (power only, angle only, power+angle, or
    complex.)

    If the bottom detection files are colocated with the .raw data, it will
    also attempt to read those files. These files must be located in the same
    directory as the .raw files and they must follow the standard Simrad naming
    convention. Supported formats include only .bot and .xyz files (default
    preference is for .xyz.) While the underlying classes support reading .out
    files, this simplified interface does not.

    Args:
            files (list): List containing full paths to data file or files
                to be read. Required.

        Additional arguments can be passed to control what data is read from
        the file. The follow arguments will filter data when reading, jumping
        over datagrams that aren't specified to be read. Arguments can be
        combined

            frequencies (list): List of floats specifying the frequency or
                frequencies you want to read from the file. Data from other
                frequencies will be ignored. Set to None to read all frequencies.

                Default: None

            channel_ids (list): A list of strings that contain the unique
                channel IDs to read. Set to None to read all channels in the
                file.

                Default: None

            start_time (datetime64): Specify a start time if you do not want
                to start reading from the first ping. Set to None to start
                reading from the first ping.

                Default: None

            end_time (datetime64): Specify an end time if you do not want to read
                to the last ping.  Set to None to read through the last ping.

                Default: None

            start_ping (int): Specify starting ping number if you do not want
                to start reading at first ping. Set to None to start reading from
                the first ping. Ping numbers start at 1 and increment for each
                distinct transmission time encountered in the data file(s) passed
                to echosounder.read().

                Default: None

            end_ping (int): Specify end ping number if you do not want
                to read all pings. Set to None to read through the last ping.
                Ping numbers start at 1 and increment for each distinct transmission
                time encountered in the data file(s) passed to echosounder.read().

                Default: None

            nmea (bool): Set to True to store NMEA data. When set to False,
                all NMEA datagrams are skipped.

                Default: True


        These arguments also filter what data is stored, but they are applied after
        the filtering performed by the keywords above. These filters require reading
        and parsing of the raw datagrams so they are not as efficient as the filters
        above but hey will still allow you to manage memory usage.


            power (bool): Controls whether power data is stored. Set to True
                to store power data. False to ignore it.

                Default: True

            angles (bool): Controls whether angle data is stored. Set to True
                to store angle data. False to ignore it.

                Default: True

            complex (bool): Controls whether complex data is stored. Set to True
                to store cinplex data. False to ignore it.

                Default: True

            max_sample_count (int): Specify the max sample count to read if your
                data of interest is less than the total number of samples contained
                in the instrument files. Set to None to read all samples.

                Default: None

            start_sample (int): Specify starting sample number to store. Set to
                None to store samples starting from the first sample in the ping.

                Default: None

            end_sample (int): Specify ending sample number to store. Set to None to
                store through the last sample in the ping.

                Default: None

    """

    # if we're given a string, wrap it in a list
    if not isinstance(files, list):
        files = [files]

    #  set the default value for our data object
    data_object = None

    # Work through the list of input files
    for index, item in enumerate(files):
        filename = os.path.normpath(item)

        # Determine what kind of data file we have
        try:
            data_type = _check_filetype(filename)
        except:
            raise FileNotFoundError("Unable to open file: " + filename)

        if data_object is None:
            #  This is the first file we're reading so we need to create the data object
            if data_type == SIMRAD_EK60:
                # This is an EK60 file, we're going to assume all files are EK60
                data_object = EK60.EK60()
            elif data_type == SIMRAD_EK80:
                # This is an EK80 file, we're going to assume all files are EK80
                data_object = EK80.EK80()
            else:
                # We don't know what this is
                raise UnknownFormatError("Unknown file type encountered: " + filename)

        #  check to make sure all of the files share the same file format
        elif ((data_type == SIMRAD_EK60 and isinstance(data_object, EK80.EK80)) or
              (data_type == SIMRAD_EK80 and isinstance(data_object, EK60.EK60))):
            # We've encountered a file with a different type than the initial file read
                raise TypeError("Mixed Ex80 and Ex60 data files encountered. The echosounder " +
                        "module does not support reading mixed data file formats at one time. " +
                        "Either read these files in separate calls to echosounder.read() or " +
                        "implement your code using the underlying EK60 and EK80 classes.")

        # Read the data file using the object for this data type
        data_object.append_raw(filename, **kwargs)

        #  now try to read the bottom data. We are assuming the .bot or .XYZ files are colocated
        #  with the .raw file and that they follow the normal Simrad naming convention.
        if data_type == SIMRAD_EK80:
            #  Simrad EK80 systems can generate both XYZ and.or .bot files
            bot_type, bot_files = simrad_utils.get_simrad_bottom_files(filename, data_object)
            if bot_type == 'BOT':
                data_object.read_bot(bot_files)
            elif bot_type == 'XYZ':
                for channel_id in bot_files:
                    data_object.read_xyz(channel_id, bot_files[channel_id])

        elif data_type == SIMRAD_EK60:
            #  Simrad EK60 systems do not generate XYZ files so we only check for .bot files
            _, bot_files = simrad_utils.get_simrad_bottom_files(filename, data_object,
                skip_xyz=True)
            if bot_files:
                data_object.read_bot(bot_files)

    return data_object


def get_calibration_from_raw(data_object, **kwargs):
    '''get_calibration_from_raw returns a dictionary, keyed by channel ID,
    containing a calibration object populated with data extracted from the
    raw data contained in the provided data_object.

    If you want to use different calibration parameters than the ones in the
    raw data, you will want to call this function to get the initial calibration
    objects and then modify them as needed.

    Like all functions in the echosounder module, this function assumes that
    your data object contains only one type of data (power only, angle only,
    power+angle, or complex) and will return data from the first data type
    only.

    data_object (EK60 or EK80 object): Set this to an instance of the EK60 or
        EK80 object that you obtained after calling echosounder.read().

    absorption_method (str): Set this to a string specifying the method used
        for computing absorption. Available methods are:

        'A&M': Computes absorption using the equation describe in:

        Ainslie M. A., McColm J. G., "A simplified formula for viscous and
          chemical absorption in sea water", Journal of the Acoustical Society
          of America, 103(3), 1671-1672, 1998.

        'F&G': Computes absorption using the equation describe in:

        Francois R. E., Garrison G. R., "Sound absorption based on ocean
          measurements: Part II:Boric acid contribution and equation for
          total absorption", Journal of the Acoustical Society of America,
          72(6), 1879-1890, 1982.

        Default value is 'F&G'

    '''

    calibrations = {}

    for chan in data_object.raw_data:
        calibrations[chan] = data_object.raw_data[chan][0].get_calibration(**kwargs)

    return calibrations


def get_calibration_from_ecs(data_object, ecs_file, channel_map=None, **kwargs):
    '''get_calibration_from_ecs will returns a dictionary, keyed by channel ID,
    containing a calibration object populated with data extracted from an Echoview
    .ecs file. Calibration parameters not present or commented out in the .ecs file
    will be populated from the raw data contained in the provided data_object.


    Like all functions in the echosounder module, this function assumes that
    your data object contains only one type of data (power only, angle only,
    power+angle, or complex) and will return data from the first data type
    only.

    data_object (EK60 or EK80 object): Set this to an instance of the EK60 or
        EK80 object that you obtained after calling echosounder.read().

    ecs_file (str): Set this to the full path to the .ecs file you want to read.

    absorption_method (str): Set this to a string specifying the method used
        for computing absorption. Available methods are:

        'A&M': Computes absorption using the equation describe in:

        Ainslie M. A., McColm J. G., "A simplified formula for viscous and
          chemical absorption in sea water", Journal of the Acoustical Society
          of America, 103(3), 1671-1672, 1998.

        'F&G': Computes absorption using the equation describe in:

        Francois R. E., Garrison G. R., "Sound absorption based on ocean
          measurements: Part II:Boric acid contribution and equation for
          total absorption", Journal of the Acoustical Society of America,
          72(6), 1879-1890, 1982.

        Default value is 'F&G'

    '''

    calibrations = {}
    last_chan = None
    T = 1

    for chan in data_object.raw_data:
        calibrations[chan] = data_object.raw_data[chan][0].get_calibration(**kwargs)

        #  Generate the EV calibration label.
        #  First parse the channel ID for channel number
        chan_parts = chan.split('_')

        #  check if this is a new transceiver+transducer
        if last_chan is not None:
            if last_chan != chan:
                #  we have a new one, increment the counter
                T += 1
                last_chan = chan
        else:
            #  this is the first channel we have encountered
            last_chan = chan

        #  set the base label value
        ev_cal_label = "T%i" % (T)

        #  check if we need to add a channel number
        if len(chan_parts) > 1:
            #  yes, there is a channel number attached to the channel ID
            ev_cal_label += " (channel %s)" % (chan_parts[1])

        #  finally read the ecs file and update the params in our calibration
        ecs_file = os.path.normpath(ecs_file)
        calibrations[chan].read_ecs_file(ecs_file, ev_cal_label)
    return calibrations


def get_calibration_from_xml(data_object,xml_files,calibrations = None, apply_to_matching_channels = True):
 
    '''get_calibration_from_xml returns a dictionary, keyed by channel ID,
    containing a calibration object populated with data extracted from the
    EK80 xml files provided. 
    
    The function will use the calibration parameters in the raw data to build 
    the calibration objects, and overwrite the appropriate parameters with the
    values from the xml files.

    Where multiple xml files for the same channel are provided, the function will
    average the calibration parameters for each frequency.

    data_object (EK60 or EK80 object): Set this to an instance of the EK60 or
        EK80 object that you obtained after calling echosounder.read().

    xml_files (str): Set this to the full path to the .xml file you want to read
        or provide a list of xml files.

    calibration (dict): Provide an already existing calibration dictionary keyed
        by channel ID to append new channels.

    apply_to_matching_channels (bool): Set this to True to apply the calibration
        to all matching channels, i.e., active to passive.
    
    '''
 
    # if we're given a string, wrap it in a list
    if not isinstance(xml_files, list):
        xml_files = [xml_files]
    
    # Initiate the calibrations dictionary if not provided an already existing dictionary
    if calibrations is None:
        calibrations = {}

    # Loop through the xml files and fill in the dictionary with the matching data_object channel_id as the key
    for file in xml_files:

        # Read the calibration file
        cal = EK80.ek80_calibration()
        cal.read_xml_file(file)
        # Get the channel name from the calibration file and find the corresponding channel_id in the data_object
        try: # If the channel ends in a number, include it in the channel ID
            int(cal.channel_name.split('-')[-1])
            xml_chan = cal.channel_name.split(' ')[0]+'_'+cal.channel_name.split('-')[-1]
        except:
            xml_chan = cal.channel_name.split(' ')[0]
        chan  = [s for s in data_object.channel_ids if xml_chan in s][0]

        # If the channel pulse form matches the pulse form of the data, add the calibration to the dictionary
        match = _compare_pulse(data_object.get_channel_data()[chan][0],cal)
        if match:
            if chan not in calibrations.keys():
                calibrations[chan] = []
            calibrations[chan].append(cal)

    # Create averaged calibrations for channels where multiple xml files exist
    for chan in calibrations.keys():
        
        # Check in case we've provided a calibration dictionary that already has objects in it
        if isinstance(calibrations[chan],list):

            # If there are multiple cals for the same channel, the variables from the calibration results tree are averaged
            if (len(calibrations[chan]) > 1):
                print('Multiple calibrations for channel: ',chan)

                # Create a new calibration object to store the merged calibration with the rest of the properties from the first calibration
                merged_cal = calibrations[chan][0]

                # Loop through the calibration attributes that need to be averaged
                for attr in ['gain', 'sa_correction', 'beam_width_alongship', 'beam_width_athwartship', 'angle_offset_alongship', 'angle_offset_athwartship']:
                            
                    merged_frequency,merged_val,full_frequencies,full_values = np.array([]),np.array([]), np.array([]),np.array([])

                    # For each calibration in the list for the channel...
                    for cal in calibrations[chan]: 
                        
                        # get the attribute as a function of frequency
                        current_frequency, current_gain = cal.frequency, getattr(cal,attr)

                        # If the frequency/attribute is not an array (CW data), make it an array
                        
                        if not isinstance(current_frequency,np.ndarray):
                            current_frequency = np.array([current_frequency])

                        if not isinstance(current_gain,np.ndarray):
                            current_gain = np.array([current_gain])
                            
                        # If the merged frequency array is empty, just add the current frequency array to it
                        if merged_frequency.size==0:
                            merged_frequency = current_frequency
                        else: # otherwise append the current frequency array to the merged frequency array and select only the unique values
                            merged_frequency = np.unique(np.concatenate((merged_frequency,current_frequency),0))
                        
                        # Append the current frequency and attribute values to the all frequency and attribute arrays
                        full_frequencies = np.append(full_frequencies,current_frequency)
                        full_values = np.append(full_values,current_gain)

                    # For each frequency in the new merged frequency array, calculate the mean of the attribute values that exist at that frequency
                    # For the gain and sa_correction attributes, calculate the power mean in dB
                    if attr in['gain','sa_correction']:
                        for f in merged_frequency:
                            merged_val = np.append(merged_val,10*np.log10(np.nanmean(10**(np.array(np.where(full_frequencies==f,full_values,np.nan))/10))))
                    else: # For the other attributes, calculate the linear mean
                        for f in merged_frequency:
                            merged_val = np.append(merged_val,np.nanmean((np.where(full_frequencies==f,full_values,np.nan))))

                    if len(merged_val)==1:
                        merged_val=merged_val[0]
                    # Set the merged attribute values to the merged calibration object
                    merged_cal.__setattr__(attr,merged_val)
                
                if len(merged_frequency)>1:
                    merged_cal.__setattr__('frequency',merged_frequency)
                    
                # Assign the merged calibration to the channel in the calibrations dictionary
                calibrations[chan] = merged_cal
            
            # If there is only one calibration for the channel, just pull it out of the list
            else:
                calibrations[chan] = calibrations[chan][0]
    
    # If apply_to_matching_channels is set to True, apply the calibration to all matching channels, i.e., active to passive
    if apply_to_matching_channels:
        
        # For each channel still missing a calibration, find the matching channel
        for chan in [s for s in data_object.channel_ids if s not in calibrations.keys()]:
            matching_channel = _find_matching_channel(data_object,chan)
            
            # If a matching channel is found, apply the calibration to the missing channel
            if matching_channel is not None:
                calibrations[chan] = calibrations[matching_channel]

    # Warn if there are channels in the data object that do not have a calibration
    for chan in  [s for s in data_object.channel_ids if s not in calibrations.keys()]:
        print('Warning: No calibration found for channel: ',chan)

    return calibrations


def get_Sv(data_object, linear=False, **kwargs):
    '''get_Sv returns a dictionary, keyed by channel ID, containing processed
        data object(s) containing Sv data.

        The frequencies, channel_ids, ping, and time range keywords can be set
        to limit what data is returned. These keywords can be applied together.
        Note that is generally more efficient to filter data when calling
        echosounder.read()

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channel_ids (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sv/sv. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        tvg_correction (bool): Set to True to apply TVG range correction.
            Typically you want to leave this at True.

            Default: True

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False
    '''

    return _get_processed_data(data_object, 'Sv', linear=False, **kwargs)


def get_sv(data_object, linear=True, **kwargs):
    '''get_sv returns a dictionary, keyed by channel ID, containing processed
        data object(s) containing sv data.

        The frequencies, channel_ids, ping, and time range keywords can be set
        to limit what data is returned. These keywords can be applied together.
        Note that is generally more efficient to filter data when calling
        echosounder.read()

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channel_ids (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sv/sv. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        tvg_correction (bool): Set to True to apply TVG range correction.
            Typically you want to leave this at True.

            Default: True

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False
    '''

    return _get_processed_data(data_object, 'Sv', linear=True,**kwargs)


def get_Sp(data_object, linear=True, **kwargs):
    '''get_Sp returns a dictionary, keyed by channel ID, containing processed
        data object(s) containing Sp data.

        The frequencies, channel_ids, ping, and time range keywords can be set
        to limit what data is returned. These keywords can be applied together.
        Note that is generally more efficient to filter data when calling
        echosounder.read()

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channel_ids (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sp/sp. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        tvg_correction (bool): Set to True to apply TVG range correction.
            Typically you want to leave this at True.

            Default: True

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False
    '''

    return _get_processed_data(data_object, 'Sp', linear=False, **kwargs)


def get_sp(data_object, linear=True, **kwargs):
    '''get_sp returns a dictionary, keyed by channel ID, containing processed
        data object(s) containing sp data.

        The frequencies, channel_ids, ping, and time range keywords can be set
        to limit what data is returned. These keywords can be applied together.
        Note that is generally more efficient to filter data when calling
        echosounder.read()

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channel_ids (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sv/sv. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        tvg_correction (bool): Set to True to apply TVG range correction.
            Typically you want to leave this at True.

            Default: True

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False
    '''

    return _get_processed_data(data_object, 'Sp', linear=True, **kwargs)


def get_power(data_object, linear=False, **kwargs):
    '''get_power returns a dictionary, keyed by channel ID, containing processed
        data object(s) containing power data.

        The frequencies, channel_ids, ping, and time range keywords can be set
        to limit what data is returned. These keywords can be applied together.
        Note that is generally more efficient to filter data when calling
        echosounder.read()

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channel_ids (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sv/sv. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        linear (bool): Set to True to return data in linear units.

            Default: False

        tvg_correction (bool): Set to True to apply TVG range correction.
            Typically you want to leave this at True.

            Default: True

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False
    '''

    return _get_processed_data(data_object, 'power', linear=linear, **kwargs)


def get_angles(data_object, **kwargs):
    '''get_angles returns a dictionary, keyed by channel ID, containing processed
        data object(s) containing physical angle data.

        The frequencies, channel_ids, ping, and time range keywords can be set
        to limit what data is returned. These keywords can be applied together.
        Note that is generally more efficient to filter data when calling
        echosounder.read()

        frequencies (list): Set this to a list containing the frequencies to
            return data from.

            Default: None (return all frequencies)

        channel_ids (list): Set this to a list containing the channel IDs to
            return data from.

            Default: None (return all channels)

        start_time (datetime64): Set to a numpy datetime64 oject specifying
            the start time of the data to convert. All data between the start
            and end time will be returned. If set to None, the start time is
            the first ping.

            Default: None

        end_time (datetime64): Set to a numpy datetime64 oject specifying
            the end time of the data to convert. All data between the start
            and end time will be returned. If set to None, the end time is
            the last ping.

            Default: None

        start_ping (int): Set to an integer specifying the first ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the first ping is set as the start ping.

            Default: None

        end_ping (int): Set to an integer specifying the end ping number
            to return. All pings between the start and end ping will be
            returned. If set to None, the last ping is set as the end ping.

            Default: None

        return_indices (np.array uint32): Set this to a numpy array that contains
            the index values to return in the processed data object. This can be
            used for more advanced anipulations where start/end ping/time are
            inadequate.

            Default: None (return all pings)

        calibration (EK80.ek80_calibration): Set to an instance of
            EK80.ek80_calibration containing the calibration parameters
            you want to use when transforming to Sv/sv. If no calibration
            object is provided, the values will be extracted from the raw
            data.

            Default: None

        return_depth (bool): Set to True to return a processed_data object
            with a depth axis. When False, the processed_data object has
            a range axis.

            Default: False

        heave_correct (bool): Set to True to return a processed_data object
            that has heave correction applied. Heave correction shifts samples
            vertically to compensate for the sounder platform's vertical motion.
            Heave corrected data is always returned as depth.

            Default: False
    '''

    return _get_processed_data(data_object, 'angles', **kwargs)

def _get_processed_data(data_object, data_type, fm_frequency_domain=True, calibration=None,
        frequencies=None, channel_ids=None, heave_correct=False, **kwargs):
    '''_get_processed_data is an internal function that returns a dictionary,
        keyed by channel ID, containing processed_data objects containing the
        specified data type. Valid data_types are 'Sv', 'power', 'Sp', 'angles'

        This function is not intended to be called directly. Instead you should
        call get_Sv(), get_Sp(), get_power(), etc.
    '''

    data = {}

    #  iterate thru all of the channels
    for chan in data_object.raw_data:

        #  get a reference to this channel's raw data
        raw_obj = data_object.raw_data[chan][0]

        #  check if we're returning this channel
        return_chan = _filter_channel(chan, raw_obj, channel_ids, frequencies, data_type)


        # if we are, get all of the data
        if return_chan:
            #  first, get a calibration object for this channel
            if calibration:
                if chan in calibration:
                    #  one is provided
                    cal_obj = calibration[chan]
                else:
                    #  cal dict provided but this channel not in it - get from raw
                    cal_obj = raw_obj.get_calibration()
            else:
                #  no cal provided - get one using the raw file parameters
                cal_obj = raw_obj.get_calibration()
            #  then get the data
            if data_type == 'Sv':
                if raw_obj.is_fm() & fm_frequency_domain:
                    p_data = raw_obj.get_Svf(calibration=cal_obj, **kwargs)
                else:
                    p_data = raw_obj.get_Sv(calibration=cal_obj, **kwargs)
            elif data_type == 'Sp':
                p_data = raw_obj.get_Sp(calibration=cal_obj, **kwargs)
            elif data_type == 'power':
                p_data = raw_obj.get_power(calibration=cal_obj, **kwargs)
            elif data_type == 'angles':
                p_data = raw_obj.get_physical_angles(calibration=cal_obj, **kwargs)

            #  add the navigation and motion data - this takes the asynchronous NMEA
            #  and motion data and interpolates it onto the ping time axis and stores
            #  the data in the processed data object.

            #  first add the NMEA data - This will add the position, speed, attitude,
            #  and distance meta-types (see instruments.util.nmea_data for more info)
            p_data.set_navigation(data_object.nmea_data)

            #  then add the motion data - we'll check if we have lat data from the NMEA
            #  data and if not, try to get it from the motion data. Some EK80 configurations
            #  may only store lat/lon in the motion data and not as NMEA data.
            if not hasattr(p_data, 'latitude'):
                #  we didn't get lat/lon from the NMEA data so try to get it from motion data
                p_data.set_motion(data_object.motion_data, motion_attributes=['pitch',
                        'roll', 'heave', 'heading', 'latitude', 'longitude'])
            else:
                #  we have lat (and presumably lon) data so we just get the "regular" motion
                #  data (pitch, roll, heave, heading)
                p_data.set_motion(data_object.motion_data)

            #  apply heave correction if needed - this has no effect if heave
            #  data is not available.
            if heave_correct:
                p_data.heave_correct()

            #  get the bottom detection data. This method will automatically
            #  correct depths as needed if the calibration sound speed is different
            #  from the sound speed at the time of collection.
            bottom_line = raw_obj.get_bottom(calibration=cal_obj, **kwargs)

            if bottom_line is not None:
                #  Bottom data is always recorded as depth with heave correction applied,
                #  so we need to back out transducer Z offset and/or heave (if applicable)
                #  when returning sample data with range as the vertical axis
                v_axis = p_data.get_v_axis()[1]
                if v_axis == 'range':
                    #  the transducer_draft attribute of the bottom line contains both
                    #  the z offset and heave. We simply subtract these values from the
                    #  line data to get the line in range.
                    bottom_line = bottom_line - bottom_line.transducer_draft
                else:
                    #  we're returning data as depth. We don't need to back out transducer
                    #  z offset, but we have to back out heave correction if the user has
                    #  not heave corrected the sample data
                    if not heave_correct:
                        #  heave correction is not set, subtract heave from the bottom line
                        bottom_line = bottom_line - p_data.heave

                #  insert the bottom detection line into the processed data object
                p_data.bottom_line = bottom_line

            #  and add the data to our return dict
            data[chan] = p_data

    return data


def _filter_channel(chan, raw_obj, channels, frequencies,data_type):

    return_chan = False
    if channels is None and frequencies is None:
        return_chan = True
    elif channels is None and raw_obj.configuration[0]['transducer_frequency'] in frequencies:
        return_chan = True
    elif frequencies is None and chan in channels:
        return_chan = True
    elif chan in channels and raw_obj.configuration[0]['transducer_frequency'] in frequencies:
        return_chan = True
    
    if (data_type=='Svf') and (hasattr(raw_obj,'complex') is False):
        return_chan = False # If we don't have complex we can't caluclate Svf

    return return_chan


def _check_filetype(filename):

    # Read in the file header, this value can change if additional
    # instruments are introduced with larger headers.
    fh = open(filename, "rb")
    header = fh.read(8)
    fh.close()

    # Return the file type based on the header
    if header[4:8]==b'CON0':
        # Simrad EK60 style raw files start  with 4 bytes for the size then C O N 0
        return SIMRAD_EK60

    elif header[4:8]==b'XML0':
        # Simrad EK80 style raw files start with 4 bytes for the size then X M L 0
        return SIMRAD_EK80

    else:
       return -1

def _find_matching_channel(raw_obj,channel_id):
        '''
        Simple approach to finding matching channel based on pre-defined attributes. Acts a 
        a helper function for the get_calibration_from_xml function to find the matching channels
        via _compare_pulse function.
        '''

        # Simplest approach, look for the matching transceiver name
        for ch_id in raw_obj.channel_ids:
            matching = [s for s in raw_obj.channel_ids if channel_id[:-2] in s and s!=channel_id]
        
        # If there are any other channels with matching transciever names, check if the other attributes match
        if matching:
            for ch in matching:
                all_match = _compare_pulse(raw_obj.get_channel_data()[channel_id][0],raw_obj.get_channel_data()[ch][0])
                
                # If all attributes match, return the channel
                if all_match:
                    return ch                        
        # If no matching channel is found, return None
        else:
            return None

def _compare_pulse(primary_obj,secondary_obj):
    '''
    Compares the pulse attributes between two data objects (raw, processed, calibration)
    and returns True if all attributes match, False if any do not match.
    
    primary_obj (object): raw or processed data object

    secondary_obj (object): raw, processed, or calibration data object
    '''

    # Attrubutes to compare based on pulse form
    if primary_obj.is_fm():
        pulse_attrs = ['pulse_form','frequency_end','pulse_duration','transmit_power']
    else:
        pulse_attrs = ['pulse_form','frequency','pulse_duration','transmit_power']

    all_match = True # Assume they match until proven otherwise
    
    for attr in pulse_attrs:
        # Check if the attribute exists in both channels
        if hasattr(secondary_obj,attr):
            # Check if the attribute values match
            if np.unique(getattr(primary_obj,attr))[0] != np.unique(getattr(secondary_obj,attr))[0]:
                all_match = False
        else:
            all_match = False

    return all_match


class UnknownFormatError(Exception):
    pass
